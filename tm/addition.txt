states 21
s0
s1
a0
a1
b0
b1
c0
c1
c2
d0
d1
d2
e0
e1
f0
f1
g0
g1
h0
h1
t +
alphabet 3 0 1 #
# First, it reads the least significant bit of the first number
s0 0 a0 _ R
s0 1 a1 _ R
# State s1 is used when the initial value is 1
s1 0 a1 _ R
s1 1 a0 _ R
# Then, it moves right until it reaches the #
a0 0 a0 0 R
a0 1 a0 1 R
a0 _ a0 _ R
a0 # b0 # R
a1 0 a1 0 R
a1 1 a1 1 R
a1 _ a1 _ R
a1 # b1 # R
# Then, it adds the two bits together and stores the result
b0 0 c0 _ R
b0 1 c1 _ R
b1 0 c1 _ R
b1 1 c2 _ R
# It moves right again until it finds another #
c0 0 c0 0 R
c0 1 c0 1 R
c0 _ c0 _ R
c0 # d0 # R
c1 0 c1 0 R
c1 1 c1 1 R
c1 _ c1 _ R
c1 # d1 # R
c2 0 c2 0 R
c2 1 c2 1 R
c2 _ c2 _ R
c2 # d2 # R
# Then, it checks to see if the sums match up
# It also stores the digit that needs to be carried up to the next place
d0 0 e0 _ R
d1 1 e0 _ R
d2 0 e1 _ R
# Check to see if this is the last digit, terminates if it is
e0 _ t _ S
e1 _ t _ S
e0 0 f0 0 L
e0 1 f0 1 L
e1 0 f1 0 L
e1 1 f1 1 L
# Then, it goes back until the second #
f0 0 f0 0 L
f0 1 f0 1 L
f0 _ f0 _ L
f0 # g0 # L
f1 0 f1 0 L
f1 1 f1 1 L
f1 _ f1 _ L
f1 # g1 # L
# And then the first #
g0 0 g0 0 L
g0 1 g0 1 L
g0 # h0 # L
g1 0 g1 0 L
g1 1 g1 1 L
g1 # h1 # L
# Then, it goes back until it finds a blank space
h0 0 h0 0 L
h0 1 h0 1 L
h1 0 h1 0 L
h1 1 h1 1 L
# Goes back to the initial state when it does find a blank space
h0 _ s0 _ R
h1 _ s1 _ R